import MdxLayout from "../../components/mdx-layout";

# Representing Expressions

As a Computer Algebra System, Ora's primary mode is symbolic computation. Many languages provide constructs that make it easier, relatively speaking, to simulate, if not implement, symbolic manipulation. The many Lisp variants, OCaml, Haskell, and so on, all provide mechanisms that make it easy to work with symbols. Pattern-matching, for example, is a great thing to have when you're working with lots of types. Alas, TypeScript—the language Ora's written in—isn't part of the roster.

Writing Ora, the first problem I had to think about (and still continue to think about) is how best to represent expressions. 

One way to represent expressions is simply with arrays. The first element of the array would tell us its type, and the rest of the array would contain the actual substantive data underlying the expression. For example, we might represent the integer ${7}$ as:

~~~ts
["int", 7]
~~~

A variable might be:

~~~ts
["sym", "x"]
~~~

The expression ${7 + x}$ could then be represented as:

~~~ts
["+", ["int", 7], ["sym", "x"]]
~~~

This is an appealing way to represent expressions. For starters, arrays are simple. They're a sequential, flat data structure, so it's fairly easy to reason about the data we're working with. What's this expression's type? Look at the first element. What's in it? Look at the rest.

The downside to this approach? You don't get some of the nicer benefits of object-oriented programming. Inheritance, for example, is a nice to have. Having methods associated with particular types is also pretty convenient.

A bigger issue, however, is tackling the [expression problem](https://en.wikipedia.org/wiki/Expression_problem).

Ultimately, I opted to representing expressions with objects.


export default function MDXPage({ children }) {
	return <MdxLayout>{children}</MdxLayout>
}
